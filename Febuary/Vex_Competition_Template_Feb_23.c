#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  frontRightEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  backLeftEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  frontLeftEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  pegsolenoid,    sensorDigitalOut)
#pragma config(Sensor, dgtl10, cubeSolenoid,   sensorDigitalOut)
#pragma config(Sensor, dgtl11, backRightEncoder, sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  armRight,       sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  armLeft,        sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           rightArm1,     tmotorVex393, openLoop)
#pragma config(Motor,  port2,           leftArm2,      tmotorVex393, openLoop, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port3,           leftArm3,      tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port4,           backRight,     tmotorVex393, openLoop)
#pragma config(Motor,  port5,           frontRight,    tmotorVex393, openLoop)
#pragma config(Motor,  port6,           backLeft,      tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port7,           frontLeft,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port8,           rightArm2,     tmotorVex393, openLoop, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port9,           rightArm3,     tmotorVex393, openLoop)
#pragma config(Motor,  port10,          leftArm1,      tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

void armUp(){
	motor[leftArm1] = 127;
	motor[leftArm2] = 127;
	motor[leftArm3] = 127;
	motor[rightArm1] = 127;
	motor[rightArm2] = 127;
	motor[rightArm3] = 127;
}

void armDown(){
	motor[leftArm1] = -127;
	motor[leftArm2] = -127;
	motor[leftArm3] = -127;
	motor[rightArm1] = -127;
	motor[rightArm2] = -127;
	motor[rightArm3] = -127;
}

void armStop(){
	motor[leftArm1] = 0;
	motor[leftArm2] = 0;
	motor[leftArm3] = 0;
	motor[rightArm1] = 0;
	motor[rightArm2] = 0;
	motor[rightArm3] = 0;
}

void pre_auton(){
  bStopTasksBetweenModes = true;
}

task autonomous(){
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol(){
	while(true){
		if(!vexRT[Btn5U] && !vexRT[Btn5D] && !vexRT[Btn6U] && !vexRT[Btn6D] && !vexRT[Btn8U] && !vexRT[Btn8D] && !vexRT[Btn8R] && !vexRT[Btn8L]){
			/*motor[frontRight] = vexRT[Ch2] - vexRT[Ch1];
	    motor[backRight]  = vexRT[Ch2] + vexRT[Ch1];
	    motor[backLeft]   = vexRT[Ch3] - vexRT[Ch4];
	    motor[frontLeft]  = vexRT[Ch3] + vexRT[Ch4];*/
	   	motor[frontLeft] = vexRT[Ch2] - vexRT[Ch1];
	    motor[backLeft]  = vexRT[Ch2] + vexRT[Ch1];
	    motor[backRight]   = vexRT[Ch3] - vexRT[Ch4];
	    motor[frontRight]  = vexRT[Ch3] + vexRT[Ch4];
	  }
    if(vexRT[Btn6UXmtr2]){
    	armUp();
    }else if(vexRT[Btn6DXmtr2]){
    	armDown();
  	}else{
  		armStop();
  	}
  	if(vexRT[Btn5U]){
			motor[frontRight] = -127;
			motor[frontLeft] = 127;
			motor[backRight] = -127;
			motor[backLeft] = 127;
  	}else if(vexRT[Btn6U]){
			motor[frontRight] = 127;
			motor[frontLeft] = -127;
			motor[backRight] = 127;
			motor[backLeft] = -127;
  	}else if(vexRT[Btn5D]){
			motor[frontRight] = -64;
			motor[frontLeft] = 64;
			motor[backRight] = -64;
			motor[backLeft] = 64;
  	}else if(vexRT[Btn6D]){
			motor[frontRight] = 64;
			motor[frontLeft] = -64;
			motor[backRight] = 64;
			motor[backLeft] = -64;
  	}
  	if(vexRT[Btn8U]){
			motor[frontRight] = 127;
			motor[frontLeft] = 127;
			motor[backRight] = 127;
			motor[backLeft] = 127;
  	}else if(vexRT[Btn8L]){
			motor[frontRight] = 127;
			motor[frontLeft] = 127;
			motor[backRight] = -127;
			motor[backLeft] = -127;
  	}else if(vexRT[Btn8D]){
			motor[frontRight] = -127;
			motor[frontLeft] = -127;
			motor[backRight] = -127;
			motor[backLeft] = -127;
  	}else if(vexRT[Btn8R]){
			motor[frontRight] = -127;
			motor[frontLeft] = -127;
			motor[backRight] = 127;
			motor[backLeft] = 127;
  	}
  	if(vexRT[Btn8DXmtr2] == 1){
  		SensorValue[pegsolenoid] = 0;
  	}else{
  		SensorValue[pegsolenoid] = 1;
  	}
  	if(vexRT[Btn8RXmtr2] == 1){
  		SensorValue[cubeSolenoid] = 0;
  	}else{
  		SensorValue[cubeSolenoid] = 1;
  	}
	}
}
