#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  frontLeftEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  frontRightEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  backRightEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  cubesolenoid,   sensorDigitalOut)
#pragma config(Sensor, dgtl10, pegSolenoid,    sensorDigitalOut)
#pragma config(Sensor, dgtl11, backLeftEncoder, sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  armRight,       sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  armLeft,        sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           rightArm1,     tmotorVex393, openLoop)
#pragma config(Motor,  port2,           leftArm2,      tmotorVex393, openLoop, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port3,           leftArm3,      tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port4,           backRight,     tmotorVex393, openLoop)
#pragma config(Motor,  port5,           frontRight,    tmotorVex393, openLoop)
#pragma config(Motor,  port6,           backLeft,      tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port7,           frontLeft,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port8,           rightArm2,     tmotorVex393, openLoop, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port9,           rightArm3,     tmotorVex393, openLoop)
#pragma config(Motor,  port10,          leftArm1,      tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


int armAverage;
int chassisAverage, absChassisAverage;

void clear(){
  SensorValue[frontLeftEncoder] = 0;
  SensorValue[frontRightEncoder] = 0;
  SensorValue[backRightEncoder] = 0;
  SensorValue[backLeftEncoder] = 0;
  SensorValue[armRight] = 0;
  SensorValue[armLeft] = 0;
  nMotorEncoder[leftArm2] = 0;
  nMotorEncoder[rightArm2] = 0;
  absChassisAverage = 0;
  chassisAverage = 0;
  armAverage = 0;
}

void updateAverages(){
		chassisAverage = (SensorValue[frontRightEncoder] + SensorValue[backLeftEncoder])/2;
		armAverage = (abs(SensorValue[armLeft]) + abs(SensorValue[armRight]))/2;
		absChassisAverage = (abs(SensorValue[frontRightEncoder]) + abs(SensorValue[backLeftEncoder]))/2;
}

void cubeGrip(){
	SensorValue[cubesolenoid] = 0;
}

void cubeRelease(){
	SensorValue[cubesolenoid] = 1;
}


void armControlUp(int target){
	float KP = 0.32;
	float KD = 0.5;

	updateAverages();

	int error = target - armAverage;
	int lastError = error;
	int deltaError = 1;
	while(abs(error)>10){

		updateAverages();
		error = target - armAverage;
		deltaError = error - lastError;
		lastError = error;

		int leftArmSpeed = error*KP-deltaError*KD;
		int rightArmSpeed = error*KP-deltaError*KD;
		if(deltaError==0 && armAverage < 400){
			leftArmSpeed +=55;
			rightArmSpeed +=55;
		}else if(deltaError==0){
			leftArmSpeed +=30;
			rightArmSpeed +=30;
		}

		/*int armDifference = (abs(SensorValue[frontRightEncoder]) - abs(SensorValue[frontLeftEncoder]))*0.2;
		leftArmSpeed += armDifference;
		rightArmSpeed -= armDifference;*/

		motor[leftArm1] = leftArmSpeed;
		motor[leftArm2] = leftArmSpeed;
		motor[leftArm3] = leftArmSpeed;
		motor[rightArm1] = rightArmSpeed;
		motor[rightArm2] = rightArmSpeed;
		motor[rightArm3] = rightArmSpeed;

	}

		motor[leftArm1] = 0;
		motor[leftArm2] = 0;
		motor[leftArm3] = 0;
		motor[rightArm1] = 0;
		motor[rightArm2] = 0;
		motor[rightArm3] = 0;
}

void armScoreUp(int target){
	float KP = 0.32;
	float KD = 0.5;

	updateAverages();

	int error = target - armAverage;
	int lastError = error;
	int deltaError = 1;
	while(abs(error)>10){

		updateAverages();
		error = target - armAverage;

		motor[leftArm1] = 127;
		motor[leftArm2] = 127;
		motor[leftArm3] = 127;
		motor[rightArm1] = 127;
		motor[rightArm2] = 127;
		motor[rightArm3] = 127;

	}

		motor[leftArm1] = 0;
		motor[leftArm2] = 0;
		motor[leftArm3] = 0;
		motor[rightArm1] = 0;
		motor[rightArm2] = 0;
		motor[rightArm3] = 0;
}


float KP = 0.25;
float KD = 0.25;


void chassisControlLeft(int target){

	updateAverages();

	int error = target - absChassisAverage;
	int lastError = error;
	while(abs(error)>5){

		updateAverages();
		error = target - absChassisAverage;
		int deltaError = error - lastError;
		lastError = error;

		int leftSpeed = error*KP+deltaError*KD+30;
		int rightSpeed = error*KP+deltaError*KD+30;

		motor[frontRight] = -rightSpeed;
		motor[frontLeft] = leftSpeed*0.92;
		motor[backRight] = -rightSpeed;
		motor[backLeft] = leftSpeed*0.96;
	}

	motor[frontRight] = 0;
	motor[frontLeft] = 0;
	motor[backRight] = 0;
	motor[backLeft] = 0;

}

void forward(int target){

	updateAverages();

	int error = target - absChassisAverage;
	int lastError = error;
	while(abs(error)>5){

		updateAverages();
		error = target - absChassisAverage;
		int deltaError = error - lastError;
		lastError = error;

		//int leftSpeed = error*KP-deltaError*KD+30;
		//int rightSpeed = error*KP-deltaError*KD+30;
		int leftSpeed = 127;
		int rightSpeed = 127;

		/*int chassisDifference = (abs(SensorValue[frontRightEncoder]) - abs(SensorValue[frontLeftEncoder]))*0.2;
		leftSpeed += chassisDifference;
		rightSpeed -= chassisDifference;*/

		motor[frontRight] = 127;
		motor[frontLeft] = 127;
		motor[backRight] = 127;
		motor[backLeft] = 127;
	}

	motor[frontRight] = 0;
	motor[frontLeft] = 0;
	motor[backRight] = 0;
	motor[backLeft] = 0;
}
void backwards(int target){

	updateAverages();

	int error = target - absChassisAverage;
	int lastError = error;
	while(abs(error)>5){

		updateAverages();
		error = target - absChassisAverage;
		int deltaError = error - lastError;
		lastError = error;

		int leftSpeed = error*KP-deltaError*KD+30;
		int rightSpeed = error*KP-deltaError*KD+30;

		/*int chassisDifference = (abs(SensorValue[frontRightEncoder]) - abs(SensorValue[frontLeftEncoder]))*0.2;
		leftSpeed += chassisDifference;
		rightSpeed -= chassisDifference;*/

		motor[frontRight] = -rightSpeed;
		motor[frontLeft] = -leftSpeed*0.92;
		motor[backRight] = -rightSpeed;
		motor[backLeft] = -leftSpeed*0.96;
	}

	motor[frontRight] = 0;
	motor[frontLeft] = 0;
	motor[backRight] = 0;
	motor[backLeft] = 0;
}



void chassisControlRight(int target){

	updateAverages();

	int error = target - absChassisAverage;
	int lastError = error;
	while(abs(error)>5){

		updateAverages();
		error = target - absChassisAverage;
		int deltaError = error - lastError;
		lastError = error;

		int leftSpeed = error*KP-deltaError*KD+30;
		int rightSpeed = error*KP-deltaError*KD+30;

		motor[frontRight] = rightSpeed;
		motor[frontLeft] = -leftSpeed*0.92;
		motor[backRight] = rightSpeed;
		motor[backLeft] = -leftSpeed*0.96;
	}

	motor[frontRight] = 0;
	motor[frontLeft] = 0;
	motor[backRight] = 0;
	motor[backLeft] = 0;

}

task main(){
	cubeRelease();
	//chassisControlRight(235);
	/*cubeRelease();
	armControlUp(350);
	forward(400);
	int down = armAverage;
	clear();
	armControlDown(down-25);
	wait1Msec(300);
	cubeGrip();
	clear();
	forward(500);
	armControlUp(400);
	clear();
	forward(350);
	clear();
	armControlDown(200);
	cubeRelease();
	armControlDown(200);
	wait1Msec(400);
	cubeGrip();
	clear();
	backwards(1300);

	while()
		wait1Msec(100);

	armScoreUp(900);
	forward(200);
	cubeRelease();*/
	//chassisControlLeft(265);
	//armControlUp(350);
	forward(500);
}
