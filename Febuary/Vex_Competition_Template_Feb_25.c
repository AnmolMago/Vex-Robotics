#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  frontLeftEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  frontRightEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  backRightEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  cubesolenoid,   sensorDigitalOut)
#pragma config(Sensor, dgtl10, pegSolenoid,    sensorDigitalOut)
#pragma config(Sensor, dgtl11, backLeftEncoder, sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  armRight,       sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  armLeft,        sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           rightArm1,     tmotorVex393, openLoop)
#pragma config(Motor,  port2,           leftArm2,      tmotorVex393, openLoop, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port3,           leftArm3,      tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port4,           backRight,     tmotorVex393, openLoop)
#pragma config(Motor,  port5,           frontRight,    tmotorVex393, openLoop)
#pragma config(Motor,  port6,           backLeft,      tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port7,           frontLeft,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port8,           rightArm2,     tmotorVex393, openLoop, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port9,           rightArm3,     tmotorVex393, openLoop)
#pragma config(Motor,  port10,          leftArm1,      tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int armAverage;
int chassisAverage, absChassisAverage;

void clear(){
  SensorValue[frontLeftEncoder] = 0;
  SensorValue[frontRightEncoder] = 0;
  SensorValue[backRightEncoder] = 0;
  SensorValue[backLeftEncoder] = 0;
  SensorValue[armRight] = 0;
  SensorValue[armLeft] = 0;
  nMotorEncoder[leftArm2] = 0;
  nMotorEncoder[rightArm2] = 0;
  absChassisAverage = 0;
  chassisAverage = 0;
  armAverage = 0;
}

void updateAverages(){
		chassisAverage = (SensorValue[frontRightEncoder] + SensorValue[backLeftEncoder])/2;
		armAverage = (abs(SensorValue[armLeft]) + abs(SensorValue[armRight]))/2;
		absChassisAverage = (abs(SensorValue[frontRightEncoder]) + abs(SensorValue[backLeftEncoder]))/2;
}

float findRatioToLowest(int current){
	updateAverages();
	int lowestEncoder = SensorValue[frontRightEncoder];
	if(SensorValue[frontLeftEncoder] < lowestEncoder)
		lowestEncoder = SensorValue[frontLeftEncoder];
	if(SensorValue[backLeftEncoder] < lowestEncoder)
		lowestEncoder = SensorValue[backLeftEncoder];
	if(SensorValue[backRightEncoder] < lowestEncoder)
		lowestEncoder = SensorValue[backRightEncoder];
	int ratio = lowestEncoder/current;
	if(ratio < 0.90){
		ratio = 0.9;
	}
	return ratio;
}

void armControlBad(int speed){
	motor[leftArm1] = speed;
	motor[leftArm2] = speed;
	motor[leftArm3] = speed;
	motor[rightArm1] = speed;
	motor[rightArm2] = speed;
	motor[rightArm3] = speed;
}

void clawClose(){
	SensorValue[pegSolenoid] = 0;
}

void clawOpen(){
	SensorValue[pegSolenoid] = 1;
}

void armControlUp(int target){
	float KP = 0.32;
	float KD = 0.5;

	updateAverages();

	int error = target - armAverage;
	int lastError = error;
	int deltaError = 1;
	while(abs(error)>10){

		updateAverages();
		error = target - armAverage;
		deltaError = error - lastError;
		lastError = error;

		int leftArmSpeed = error*KP-deltaError*KD;
		int rightArmSpeed = error*KP-deltaError*KD;
		if(deltaError==0 && armAverage < 400){
			leftArmSpeed +=55;
			rightArmSpeed +=55;
		}else if(deltaError==0){
			leftArmSpeed +=30;
			rightArmSpeed +=30;
		}

		/*int armDifference = (abs(SensorValue[frontRightEncoder]) - abs(SensorValue[frontLeftEncoder]))*0.2;
		leftArmSpeed += armDifference;
		rightArmSpeed -= armDifference;*/

		motor[leftArm1] = leftArmSpeed;
		motor[leftArm2] = leftArmSpeed;
		motor[leftArm3] = leftArmSpeed;
		motor[rightArm1] = rightArmSpeed;
		motor[rightArm2] = rightArmSpeed;
		motor[rightArm3] = rightArmSpeed;

	}

		motor[leftArm1] = 0;
		motor[leftArm2] = 0;
		motor[leftArm3] = 0;
		motor[rightArm1] = 0;
		motor[rightArm2] = 0;
		motor[rightArm3] = 0;
}

void armControlDown(int target){
	float KP = 0.32;
	float KD = 0.5;

	updateAverages();

	int error = target - armAverage;
	int lastError = error;
	int deltaError = 1;
	while(abs(error)>10){

		updateAverages();
		error = target - armAverage;
		deltaError = error - lastError;
		lastError = error;

		int leftArmSpeed = error*KP-deltaError*KD;
		int rightArmSpeed = error*KP-deltaError*KD;
		if(deltaError==0 && armAverage > (target-100)){
			break;
		}

		/*int armDifference = (abs(SensorValue[frontRightEncoder]) - abs(SensorValue[frontLeftEncoder]))*0.2;
		leftArmSpeed += armDifference;
		rightArmSpeed -= armDifference;*/

		motor[leftArm1] = -leftArmSpeed;
		motor[leftArm2] = -leftArmSpeed;
		motor[leftArm3] = -leftArmSpeed;
		motor[rightArm1] = -rightArmSpeed;
		motor[rightArm2] = -rightArmSpeed;
		motor[rightArm3] = -rightArmSpeed;

	}

		motor[leftArm1] = 0;
		motor[leftArm2] = 0;
		motor[leftArm3] = 0;
		motor[rightArm1] = 0;
		motor[rightArm2] = 0;
		motor[rightArm3] = 0;
}

void armControlDownRelease(int target, int release){
	float KP = 0.32;
	float KD = 0.5;

	updateAverages();

	int error = target - armAverage;
	int lastError = error;
	int deltaError = 1;
	while(abs(error)>10){

		if(armAverage > release){
			clawOpen();
		}

		updateAverages();
		error = target - armAverage;
		deltaError = error - lastError;
		lastError = error;

		int leftArmSpeed = error*KP-deltaError*KD;
		int rightArmSpeed = error*KP-deltaError*KD;
		if(deltaError==0 && armAverage > (target-100)){
			break;
		}

		/*int armDifference = (abs(SensorValue[frontRightEncoder]) - abs(SensorValue[frontLeftEncoder]))*0.2;
		leftArmSpeed += armDifference;
		rightArmSpeed -= armDifference;*/

		motor[leftArm1] = -leftArmSpeed;
		motor[leftArm2] = -leftArmSpeed;
		motor[leftArm3] = -leftArmSpeed;
		motor[rightArm1] = -rightArmSpeed;
		motor[rightArm2] = -rightArmSpeed;
		motor[rightArm3] = -rightArmSpeed;

	}

		motor[leftArm1] = 0;
		motor[leftArm2] = 0;
		motor[leftArm3] = 0;
		motor[rightArm1] = 0;
		motor[rightArm2] = 0;
		motor[rightArm3] = 0;
}

	float KP = 0.25;
	float KD = 0.25;
void chassisControlLeft(int target){

	updateAverages();

	int error = target - absChassisAverage;
	int lastError = error;
	while(abs(error)>5){

		updateAverages();
		error = target - absChassisAverage;
		int deltaError = error - lastError;
		lastError = error;

		int leftSpeed = error*KP+deltaError*KD+30;
		int rightSpeed = error*KP+deltaError*KD+30;

		motor[frontRight] = -rightSpeed;
		motor[frontLeft] = leftSpeed*0.92;
		motor[backRight] = -rightSpeed;
		motor[backLeft] = leftSpeed*0.96;
	}

	motor[frontRight] = 0;
	motor[frontLeft] = 0;
	motor[backRight] = 0;
	motor[backLeft] = 0;

}

void chassisControlRight(int target){

	updateAverages();

	int error = target - absChassisAverage;
	int lastError = error;
	while(abs(error)>5){

		updateAverages();
		error = target - absChassisAverage;
		int deltaError = error - lastError;
		lastError = error;

		int leftSpeed = error*KP-deltaError*KD+30;
		int rightSpeed = error*KP-deltaError*KD+30;

		motor[frontRight] = rightSpeed;
		motor[frontLeft] = -leftSpeed*0.92;
		motor[backRight] = rightSpeed;
		motor[backLeft] = -leftSpeed*0.96;
	}

	motor[frontRight] = 0;
	motor[frontLeft] = 0;
	motor[backRight] = 0;
	motor[backLeft] = 0;

}

int up[6] =     {300, 400, 450, 550, 700, 850};
//int down[6] ={250, 250, 350, 400, 600, 725};
int release[6] ={225, 250, 250, 225, 225, 250};

void helper(int count){
	int value = 555;
	if(count==0)
		value-=5;
	clear();
	clawClose();
	wait1Msec(250);
	armControlUp(up[count]);
	wait1Msec(250);
	chassisControlLeft(value);
	wait1Msec(250);
	int down = armAverage;
	clear();
	if(count == 0){
		armControlDown(down-25);
		wait1Msec(1000);
		clawOpen();
	}else{
		armControlDownRelease(down-25, release[count]);
	}
	wait1Msec(500);
	if(count>=3)
		value+=15;
	if(count == 5)
		return;
	chassisControlRight(value-5);
	wait1Msec(500);
	clear();
}

task main(){
	chassisControlRight(250);
	//clawOpen();
	/*armControlBad(127);
	wait1Msec(250);
	armControlBad(-127);
	wait1Msec(250);
	armControlBad(0);
	clawOpen();
	wait1Msec(500);
	chassisControlRight(250);
	wait1Msec(300);
	helper(0);
	helper(1);
	helper(2);
	helper(3);
	helper(4);
	helper(5);
	/*armControlBad(127);
	wait1Msec(250);
	armControlBad(-127);
	wait1Msec(250);
	armControlBad(0);
	chassisControlRight(260);
	wait1Msec(100);
	clawClose();
	/*helper(0);
	helper(1);
	helper(2);
	helper(3);
	helper(4);
	helper(5);
	/*armControlUp(200);
	while(true)
	while(true)
	motor[port2] = 127;
	int speed = 40;
	motor[leftArm1] = speed;
	motor[leftArm2] = speed;
	motor[leftArm3] = speed;
	motor[rightArm1] = speed;
	motor[rightArm2] = speed;
	motor[rightArm3] = speed;
	wait1Msec(1500);
	speed = 0;
	motor[leftArm1] = speed;
	motor[leftArm2] = speed;
	motor[leftArm3] = speed;
	motor[rightArm1] = speed;
	motor[rightArm2] = speed;
	motor[rightArm3] = speed;*/

}
